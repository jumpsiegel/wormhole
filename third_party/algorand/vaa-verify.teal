#pragma version 5
txn Fee
int 1000
<=
assert
txn NumAppArgs
int 3
==
assert
arg 0
len
txn GroupIndex
txna ApplicationArgs 2
btoi
callsub sub2
int 66
*
==
assert
txn RekeyTo
global ZeroAddress
==
assert
txn ApplicationID
int 0
==
assert
txn TypeEnum
int appl
==
assert
global GroupSize
txna ApplicationArgs 2
btoi
callsub sub1
==
assert
arg 0
txn Note
txna ApplicationArgs 1
callsub sub3
assert
int 1
return
sub0: // ceil
store 2
store 1
load 1
load 2
%
int 0
!=
bnz sub0_l2
load 1
load 2
/
retsub
sub0_l2:
load 1
load 2
/
int 1
+
retsub
sub1: // get_group_size
store 0
load 0
int 6
callsub sub0
retsub
sub2: // get_sig_count_in_step
store 4
store 3
load 4
int 6
%
int 0
==
bnz sub2_l4
load 3
load 4
callsub sub1
int 1
-
<
bnz sub2_l3
load 4
int 6
%
retsub
sub2_l3:
int 6
retsub
sub2_l4:
int 6
retsub
sub3: // sig_check
store 7
store 6
store 5
byte ""
store 240
byte ""
store 241
int 0
store 10
int 0
store 8
int 0
store 9
sub3_l1:
load 8
load 5
len
<
bz sub3_l3
load 5
load 8
int 1
extract3
btoi
load 10
txn GroupIndex
int 6
*
+
==
assert
load 6
keccak256
load 5
load 8
int 65
+
int 1
extract3
btoi
load 5
load 8
int 1
+
int 32
extract3
load 5
load 8
int 33
+
int 32
extract3
ecdsa_pk_recover Secp256k1
store 241
store 240
load 7
load 9
int 20
extract3
load 240
load 241
concat
keccak256
int 12
int 32
substring3
==
assert
load 8
int 66
+
store 8
load 9
int 20
+
store 9
load 10
int 1
+
store 10
b sub3_l1
sub3_l3:
int 1
retsub